// Code generated by vfsgen; DO NOT EDIT.

// +build !dev

package frontend

import (
	"bytes"
	"compress/gzip"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	pathpkg "path"
	"time"
)

// Assets statically implements the virtual filesystem provided to vfsgen.
var Assets = func() http.FileSystem {
	fs := vfsgen۰FS{
		"/": &vfsgen۰DirInfo{
			name:    "/",
			modTime: time.Time{},
		},
		"/dist": &vfsgen۰DirInfo{
			name:    "dist",
			modTime: time.Date(2019, 9, 17, 5, 56, 13, 264417077, time.UTC),
		},
		"/dist/app.css": &vfsgen۰CompressedFileInfo{
			name:             "app.css",
			modTime:          time.Date(2019, 9, 12, 8, 13, 50, 912757920, time.UTC),
			uncompressedSize: 1896,

			compressedContent: []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xa4\x54\xd1\x8e\xea\x36\x10\x7d\xcf\x57\x8c\x84\x2a\x5a\x84\x2f\x04\x36\x5c\x30\x3f\xd0\xb7\x3e\xb4\xea\x4b\xd5\x07\xc7\x9e\x10\x6b\x1d\xdb\xb2\x27\x2c\x7b\xd1\xfe\x42\xbf\xa0\x5f\xd7\x2f\xa9\xe2\x24\x40\xf6\xde\x6d\x2b\x35\x12\x22\x9e\xd8\x67\xc6\x67\xce\x9c\xd5\x02\x7e\xd4\x0a\xa1\xb5\x4c\xba\xc6\x6b\x83\x0a\x9a\x36\x92\x90\x35\x42\xa9\xad\xd2\xf6\x14\xb3\xd6\x92\x36\x40\x35\xc2\xaf\x2d\x82\xb6\x91\x84\x95\x08\x3a\x42\x40\xa1\x5e\x61\xb1\xca\xb2\xdf\xce\x4c\x1a\x27\x9e\x7f\x87\x6b\x06\xa0\x74\xf4\x46\xbc\x72\xb0\xce\xe2\x31\x7b\xcb\xb2\x45\x17\x06\x68\x44\x38\x69\xcb\xd7\xc7\xb4\xf2\x42\x75\x19\xba\xe5\x5b\x96\x95\x4e\xbd\xf6\xbb\x2a\x67\x89\xe7\x85\xbf\xac\xf2\x4f\x5b\x98\xff\xe4\xd1\xc2\xcf\xc2\xc6\xf9\x12\xa2\xb0\x91\x45\x0c\xba\xea\x21\xa4\x33\x2e\x70\x98\x15\x58\x94\xbb\xa7\x3e\x46\x78\x21\x26\x8c\x3e\x59\x2e\xd1\x12\x86\x04\x2f\x96\x20\xf8\x59\x47\x4d\xa8\xa0\xcf\xe3\x5a\x32\xda\x22\xef\xab\xbc\xc3\xcd\xb6\xfb\x83\x92\x79\x7f\x8c\xd7\xee\x8c\xe1\x7a\x47\x56\x28\x5d\x10\xa4\x9d\xe5\xb7\xeb\x45\x94\x5d\x60\x09\x95\x73\x84\x61\x09\x35\x0a\xd5\xfd\x8b\xa8\x15\x2e\xc1\x8a\x73\x8f\x70\x63\xa6\x34\x4e\x3e\xa7\xb3\xab\x05\xfb\xe8\x49\x47\x7e\xa9\x11\x50\x69\x02\x72\xce\x90\xf6\xd9\x87\xdb\x59\xd7\x89\x4f\xc3\xb6\x3e\x5f\x29\xe4\xf3\x29\xb8\xd6\x2a\x36\xdc\xad\x90\x87\xb2\xfc\x7c\xcc\xde\x7f\xd6\x8d\x38\x21\x67\x2f\x58\x3e\x6b\x62\x1d\x2f\x22\xb0\x53\x10\x4a\xa3\xa5\xef\xc9\xf9\x25\x0c\x67\xbb\x97\xed\x61\x23\xd4\x0f\xc7\x0f\x40\x1a\xf7\xe5\xff\x21\xfc\xd7\xc3\xfd\x69\x77\x61\xb1\x16\xca\xbd\x70\x58\x43\xee\x2f\xe9\x37\x93\x52\x0e\xe8\x2e\x28\x0c\xac\xc3\x6a\x23\xdf\xfa\x4b\x1f\x7e\xd1\x8a\x6a\x0e\x9b\xc3\x7a\x8c\x8c\x7a\x84\x3c\x85\xfa\x98\x8b\x3a\xf5\x1a\x44\x19\x9d\x69\x69\x50\x8a\xc1\x8a\x78\xb1\xfe\xee\xf8\xa0\x6b\x96\x82\x2c\x2f\x6e\x88\xe4\x3c\x87\x7d\x5a\xbe\xdd\x5b\xc3\x45\x45\xa3\xa4\x56\x8b\xd4\x60\xd2\x1e\x5c\x95\x86\x6c\xd8\xd4\x8d\x55\x2f\x49\x4b\x68\x89\xcf\xe7\xc7\x69\x41\xd3\x7a\xfa\x4b\xf2\x9d\xbf\x40\x74\x46\x2b\x98\x15\xf9\x61\x2d\xa6\x14\x8c\x12\x48\x5f\x80\x82\xb0\xd1\x8b\x80\x96\x1e\xdf\x1f\xd9\x19\x06\xb5\x46\x7d\xaa\x69\x5c\x95\x8e\xc8\x35\x9c\xe5\x9b\xf1\x9a\xff\x40\xc6\xee\xdd\xdd\x41\x5b\xdf\xd2\xf5\xb1\x66\xb8\xcf\xdf\xd0\x93\x7c\x3d\x62\x75\x42\x60\x43\x7a\xd8\x3e\x8d\x09\xa7\x2d\x85\xed\x3d\xfe\x28\x85\x8d\xbf\x40\x47\xc8\xac\x2c\xcb\xce\xb7\x90\xbe\x32\x08\x18\x1d\x62\xf4\x1d\x16\xf5\x17\xe4\x90\xef\x46\xc8\x14\xac\x44\xa3\xcd\x2b\x07\x6d\x6b\x0c\x9a\xa6\xde\xb3\x57\x87\xed\xa1\x78\xd8\xfd\x32\xd4\x5b\x3a\xa3\x8e\x13\xa7\xb9\x1b\xa2\xbf\xbe\x4b\xb9\xd9\x4c\x32\x0e\x18\x77\x88\xa1\x77\x3b\xb5\x5f\xef\xf7\x93\xb6\xc0\xf6\xa6\x37\xd9\x86\xe8\x02\x57\x58\x89\xd6\x50\x9f\x08\xca\xeb\x23\x40\x95\x9e\xe3\xc4\x8d\xb4\x4d\x3c\x0f\x9e\xf4\x38\x0a\x45\x37\x4d\x37\xf8\xaf\xdd\x44\x3e\xa9\xcf\xb8\xfe\x56\x53\x6e\xd7\x49\x6c\x27\x7d\x55\x2e\x34\xbc\xf5\x1e\x83\x14\x11\xdf\x73\x9e\xef\x07\xa9\x78\x5e\x62\xe5\x02\x5e\xa7\xfa\xff\xeb\xcf\x3f\xe6\xff\x56\xf6\x20\xbd\x90\x78\x29\xbe\x45\xa8\x75\xa1\x11\xa6\x8f\x9f\x31\x90\x96\xc2\x8c\x5a\x48\x95\xf6\xea\x4e\x85\xcc\x1a\xa1\xed\xf5\x91\xea\xed\xfa\x6e\x16\xe3\x1c\x06\x34\x82\xf4\x19\x27\xc4\xb1\x34\xf9\x83\x13\xbc\xfd\x1d\x00\x00\xff\xff\x32\x66\xbf\x56\x68\x07\x00\x00"),
		},
		"/dist/app.js": &vfsgen۰CompressedFileInfo{
			name:             "app.js",
			modTime:          time.Date(2019, 9, 17, 5, 56, 13, 258269040, time.UTC),
			uncompressedSize: 447,

			compressedContent: []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\x84\x8f\xc1\x6a\xeb\x30\x10\x45\xf7\xfe\x8a\xfb\x78\x0b\x27\x60\x9c\xbd\x43\x96\xed\x17\x94\x76\x19\xa6\xd6\xd4\x1a\x90\x34\xa1\x1a\xc7\x2d\x21\xff\x5e\xea\x18\x57\xa5\x85\x6a\x21\xc4\xe8\xea\x1c\xdd\xaa\x3a\xd3\x2b\x1c\x47\xc5\x01\x89\x27\x3c\x8e\xbc\xb9\x54\x15\x00\x70\xe8\x50\xff\x8f\x24\xa9\x6e\x6e\x13\x47\x46\x1d\x2e\xf3\xf9\x73\x65\xaf\xd3\xd1\x54\x83\xc9\xa9\xc3\x0b\x85\xcc\xcd\x7a\x69\xfc\x66\xc7\x5e\x93\x71\xb2\x0e\xf5\x9d\x13\x43\xe4\xb6\x9e\x03\xd7\x85\xb8\xdb\xe1\x7e\x4c\xbd\x89\xa6\x8c\x89\x31\x49\x08\x78\x66\x8c\x59\xd2\xd0\xce\x91\xc8\xe6\xd5\xe5\xd2\xeb\xc5\xf1\xc3\xaa\x5d\xde\x6f\xb6\x5f\x81\x05\xfd\xe4\x39\x81\x10\xd5\x71\x80\x64\xf4\x9e\xd2\xc0\xae\x81\x79\xc6\x59\x78\x5a\x7d\x34\x9a\x46\x32\xe9\x29\x84\x77\x8c\x27\x47\xc6\xae\xfd\xc6\x33\x2f\xb9\x2d\x1b\xe3\x70\xab\xbc\x5f\x63\xd7\xa2\xbd\x0e\x43\xf8\xfb\x93\xbf\x41\xff\xfd\x18\x16\x86\xaa\xd8\xb7\xfb\x8f\x00\x00\x00\xff\xff\x7e\x13\xc7\x82\xbf\x01\x00\x00"),
		},
		"/templates": &vfsgen۰DirInfo{
			name:    "templates",
			modTime: time.Date(2019, 9, 17, 5, 55, 45, 386067337, time.UTC),
		},
		"/templates/index.html": &vfsgen۰CompressedFileInfo{
			name:             "index.html",
			modTime:          time.Date(2019, 9, 17, 5, 55, 45, 385156838, time.UTC),
			uncompressedSize: 655,

			compressedContent: []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\x84\x92\x4f\x6f\xdc\x20\x10\xc5\xef\xfe\x14\xd3\xb9\xe4\xb4\xe6\x5a\x45\xc0\xa5\x7f\xae\xad\xa2\xed\xa1\x8a\xa2\x88\xc2\xec\x9a\x5d\x0c\xc8\x4c\x68\x57\x51\xbe\x7b\xc5\xda\x4e\xdc\x5e\x72\xb2\x3d\x7e\xef\x37\x8f\x19\xe4\x87\xcf\xdf\x3e\xed\x7f\x7e\xff\x02\x03\x8f\x41\x77\xb2\x3d\x20\x98\x78\x54\x48\x11\x5b\x81\x8c\xd3\x1d\x00\x80\x1c\x89\x0d\xd8\xc1\x4c\x85\x58\xe1\x8f\xfd\xd7\xdd\x47\x5c\x7e\xb1\xe7\x40\xda\xd1\x98\xa4\x98\xdf\xe7\x7a\xf0\xf1\x0c\x13\x05\x85\x85\x2f\x81\xca\x40\xc4\x08\x7c\xc9\xa4\x90\xe9\x0f\x0b\x5b\x0a\xc2\x30\xd1\x41\xe1\xfd\x3d\xf4\x77\x14\x0c\xfb\x4a\x77\x29\x31\x3c\x3c\xd4\x43\x11\xce\x17\x16\x26\xe7\xbe\x49\x75\x27\xc5\x9c\x48\xfe\x4a\xee\xa2\xbb\xb9\x8d\xf3\x15\xbc\x53\x68\x72\x5e\x12\x6d\x8a\xa3\xf1\x11\xa1\xee\x6c\x48\xe6\x0c\x75\x97\xe2\xad\x0d\xde\x9e\x15\x0e\xde\xd1\x3e\xa5\xc0\x3e\x23\xe8\xae\xeb\x16\xeb\x62\xb6\xc1\x94\xa2\x90\x57\xc5\x9b\xb5\x2f\x9c\x32\xd4\x9d\x3f\x28\x2c\x43\xfa\xfd\xb8\x6a\xf4\x86\x71\xe5\xf8\x98\x9f\x78\x73\xe0\x46\x19\x93\x6b\x13\x69\x9f\x8f\x36\x45\xa6\xc8\x08\x42\xbf\x35\x17\xce\xd7\x7f\xe3\xe4\xff\x9b\xb7\x58\xc7\x63\x78\x8d\xaf\x9f\x9f\xb7\xbc\x97\x17\x29\xf2\x3a\x9d\x19\xb7\x52\xa5\x58\x26\x27\x8b\x9d\x7c\x66\x28\x93\x55\x38\x30\xe7\x72\x2b\x84\x75\xb1\x3f\x15\x47\xc1\xd7\xa9\x8f\xc4\x22\xe6\x51\xd4\x27\x42\x2d\xc5\xac\xd7\xaf\xc6\xeb\xa9\x6e\xae\x6b\x3c\x99\x6a\xe6\xea\xcd\xcc\x7b\x6f\x99\xa7\xb2\x25\xb6\xad\xb6\xfb\xf7\x37\x00\x00\xff\xff\x75\x2b\xc4\x95\x8f\x02\x00\x00"),
		},
	}
	fs["/"].(*vfsgen۰DirInfo).entries = []os.FileInfo{
		fs["/dist"].(os.FileInfo),
		fs["/templates"].(os.FileInfo),
	}
	fs["/dist"].(*vfsgen۰DirInfo).entries = []os.FileInfo{
		fs["/dist/app.css"].(os.FileInfo),
		fs["/dist/app.js"].(os.FileInfo),
	}
	fs["/templates"].(*vfsgen۰DirInfo).entries = []os.FileInfo{
		fs["/templates/index.html"].(os.FileInfo),
	}

	return fs
}()

type vfsgen۰FS map[string]interface{}

func (fs vfsgen۰FS) Open(path string) (http.File, error) {
	path = pathpkg.Clean("/" + path)
	f, ok := fs[path]
	if !ok {
		return nil, &os.PathError{Op: "open", Path: path, Err: os.ErrNotExist}
	}

	switch f := f.(type) {
	case *vfsgen۰CompressedFileInfo:
		gr, err := gzip.NewReader(bytes.NewReader(f.compressedContent))
		if err != nil {
			// This should never happen because we generate the gzip bytes such that they are always valid.
			panic("unexpected error reading own gzip compressed bytes: " + err.Error())
		}
		return &vfsgen۰CompressedFile{
			vfsgen۰CompressedFileInfo: f,
			gr:                        gr,
		}, nil
	case *vfsgen۰DirInfo:
		return &vfsgen۰Dir{
			vfsgen۰DirInfo: f,
		}, nil
	default:
		// This should never happen because we generate only the above types.
		panic(fmt.Sprintf("unexpected type %T", f))
	}
}

// vfsgen۰CompressedFileInfo is a static definition of a gzip compressed file.
type vfsgen۰CompressedFileInfo struct {
	name              string
	modTime           time.Time
	compressedContent []byte
	uncompressedSize  int64
}

func (f *vfsgen۰CompressedFileInfo) Readdir(count int) ([]os.FileInfo, error) {
	return nil, fmt.Errorf("cannot Readdir from file %s", f.name)
}
func (f *vfsgen۰CompressedFileInfo) Stat() (os.FileInfo, error) { return f, nil }

func (f *vfsgen۰CompressedFileInfo) GzipBytes() []byte {
	return f.compressedContent
}

func (f *vfsgen۰CompressedFileInfo) Name() string       { return f.name }
func (f *vfsgen۰CompressedFileInfo) Size() int64        { return f.uncompressedSize }
func (f *vfsgen۰CompressedFileInfo) Mode() os.FileMode  { return 0444 }
func (f *vfsgen۰CompressedFileInfo) ModTime() time.Time { return f.modTime }
func (f *vfsgen۰CompressedFileInfo) IsDir() bool        { return false }
func (f *vfsgen۰CompressedFileInfo) Sys() interface{}   { return nil }

// vfsgen۰CompressedFile is an opened compressedFile instance.
type vfsgen۰CompressedFile struct {
	*vfsgen۰CompressedFileInfo
	gr      *gzip.Reader
	grPos   int64 // Actual gr uncompressed position.
	seekPos int64 // Seek uncompressed position.
}

func (f *vfsgen۰CompressedFile) Read(p []byte) (n int, err error) {
	if f.grPos > f.seekPos {
		// Rewind to beginning.
		err = f.gr.Reset(bytes.NewReader(f.compressedContent))
		if err != nil {
			return 0, err
		}
		f.grPos = 0
	}
	if f.grPos < f.seekPos {
		// Fast-forward.
		_, err = io.CopyN(ioutil.Discard, f.gr, f.seekPos-f.grPos)
		if err != nil {
			return 0, err
		}
		f.grPos = f.seekPos
	}
	n, err = f.gr.Read(p)
	f.grPos += int64(n)
	f.seekPos = f.grPos
	return n, err
}
func (f *vfsgen۰CompressedFile) Seek(offset int64, whence int) (int64, error) {
	switch whence {
	case io.SeekStart:
		f.seekPos = 0 + offset
	case io.SeekCurrent:
		f.seekPos += offset
	case io.SeekEnd:
		f.seekPos = f.uncompressedSize + offset
	default:
		panic(fmt.Errorf("invalid whence value: %v", whence))
	}
	return f.seekPos, nil
}
func (f *vfsgen۰CompressedFile) Close() error {
	return f.gr.Close()
}

// vfsgen۰DirInfo is a static definition of a directory.
type vfsgen۰DirInfo struct {
	name    string
	modTime time.Time
	entries []os.FileInfo
}

func (d *vfsgen۰DirInfo) Read([]byte) (int, error) {
	return 0, fmt.Errorf("cannot Read from directory %s", d.name)
}
func (d *vfsgen۰DirInfo) Close() error               { return nil }
func (d *vfsgen۰DirInfo) Stat() (os.FileInfo, error) { return d, nil }

func (d *vfsgen۰DirInfo) Name() string       { return d.name }
func (d *vfsgen۰DirInfo) Size() int64        { return 0 }
func (d *vfsgen۰DirInfo) Mode() os.FileMode  { return 0755 | os.ModeDir }
func (d *vfsgen۰DirInfo) ModTime() time.Time { return d.modTime }
func (d *vfsgen۰DirInfo) IsDir() bool        { return true }
func (d *vfsgen۰DirInfo) Sys() interface{}   { return nil }

// vfsgen۰Dir is an opened dir instance.
type vfsgen۰Dir struct {
	*vfsgen۰DirInfo
	pos int // Position within entries for Seek and Readdir.
}

func (d *vfsgen۰Dir) Seek(offset int64, whence int) (int64, error) {
	if offset == 0 && whence == io.SeekStart {
		d.pos = 0
		return 0, nil
	}
	return 0, fmt.Errorf("unsupported Seek in directory %s", d.name)
}

func (d *vfsgen۰Dir) Readdir(count int) ([]os.FileInfo, error) {
	if d.pos >= len(d.entries) && count > 0 {
		return nil, io.EOF
	}
	if count <= 0 || count > len(d.entries)-d.pos {
		count = len(d.entries) - d.pos
	}
	e := d.entries[d.pos : d.pos+count]
	d.pos += count
	return e, nil
}
